using AttributedDI.SourceGenerator.InterfacesGeneration;
using AttributedDI.SourceGenerator.ServiceCollectionExtensionsGeneration;
using AttributedDI.SourceGenerator.ServiceModulesGeneration;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AttributedDI.SourceGenerator;

/// <summary>
///     Incremental source generator that discovers types with registration attributes and generates service registration
///     modules.
/// </summary>
[Generator]
public class ServiceRegistrationGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static postInitializationContext =>
        {
            postInitializationContext.AddEmbeddedAttributeDefinition();
            postInitializationContext.AddSource(
                "AttributedDI.Generated.Internal.GeneratedModuleAttribute.g.cs",
                SourceText.From(GeneratedModuleAttributeSource, Encoding.UTF8));
        });

        // Phase 1: locate the attributes & extract structured info for code generation.        
        var moduleToGenerate = ModuleGenerationPipeline.Collect(context);
        var generatedInterfaces = InterfaceGenerationPipeline.Collect(context);
        var addAttributedDiExtensions = AttributedDiServiceCollectionExtensionsPipeline.Collect(context, moduleToGenerate);

        // Phase 2: Generate code based on collected data
        context.RegisterSourceOutput(moduleToGenerate, static (spc, data) =>
        {
            var (registrationInfos, customNameInfo, assemblyName) = data;

            if (registrationInfos.Any())
            {
                GeneratedModuleCodeEmitter.EmitRegistrationModule(
                    spc,
                    customNameInfo.ModuleName,
                    customNameInfo.MethodName,
                    customNameInfo.Namespace,
                    assemblyName,
                    registrationInfos);
            }
        });

        context.RegisterSourceOutput(addAttributedDiExtensions, static (spc, info) =>
        {
            if (!info.IsEntryPoint)
            {
                return;
            }

            AttributedDiServiceCollectionExtensionsEmitter.EmitExtensionMethods(spc, info.ModuleTypes);
        });

        context.RegisterSourceOutput(generatedInterfaces.Collect(), static (spc, interfaces) =>
        {
            if (interfaces.IsDefaultOrEmpty)
            {
                return;
            }

            GeneratedInterfacesCodeEmitter.EmitInterfaces(spc, interfaces);
        });
    }

    private const string GeneratedModuleAttributeSource = """
// <auto-generated/>
#nullable enable

namespace AttributedDI.Generated.Internal
{
    /// <summary>
    /// Marks a generated service module to enable discovery by AttributedDI's source generator.
    /// </summary>
    [global::Microsoft.CodeAnalysis.Embedded]
    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    internal sealed class GeneratedModuleAttribute : global::System.Attribute
    {
    }
}
""";
}