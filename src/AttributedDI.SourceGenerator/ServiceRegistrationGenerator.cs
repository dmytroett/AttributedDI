using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AttributedDI.SourceGenerator
{
    /// <summary>
    /// Incremental source generator that discovers types with registration attributes and generates service registration methods.
    /// </summary>
    [Generator]
    public class ServiceRegistrationGenerator : IIncrementalGenerator
    {
        private const string RegisterBaseAttributeName = "AttributedDI.RegisterBase";
        private const string RegisterAsSelfAttributeName = "AttributedDI.RegisterAsSelfAttribute";
        private const string RegisterAsAttributeName = "AttributedDI.RegisterAsAttribute";
        private const string RegisterAsImplementedInterfacesAttributeName = "AttributedDI.RegisterAsImplementedInterfacesAttribute";

        /// <inheritdoc/>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register attribute for RegisterAsSelfAttribute
            var registerAsSelfTypes = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    RegisterAsSelfAttributeName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                    transform: static (ctx, _) => GetRegistrationInfo(ctx))
                .Where(static info => info is not null);

            // Register attribute for RegisterAsAttribute
            var registerAsTypes = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    RegisterAsAttributeName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                    transform: static (ctx, _) => GetRegistrationInfo(ctx))
                .Where(static info => info is not null);

            // Register attribute for RegisterAsImplementedInterfacesAttribute
            var registerAsInterfacesTypes = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    RegisterAsImplementedInterfacesAttributeName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                    transform: static (ctx, _) => GetRegistrationInfo(ctx))
                .Where(static info => info is not null);

            // Combine all registration types
            var allRegistrations = registerAsSelfTypes
                .Collect()
                .Combine(registerAsTypes.Collect())
                .Combine(registerAsInterfacesTypes.Collect())
                .Select(static (combined, _) =>
                {
                    var left = combined.Left;
                    var selfTypes = left.Left;
                    var asTypes = left.Right;
                    var interfaceTypes = combined.Right;

                    return selfTypes.Concat(asTypes).Concat(interfaceTypes).ToImmutableArray();
                });

            // Generate the registration extension methods
            context.RegisterSourceOutput(allRegistrations, static (spc, registrations) =>
            {
                var source = GenerateRegistrationExtensions(registrations);
                spc.AddSource("ServiceRegistrationExtensions.g.cs", source);
            });
        }

        private static RegistrationInfo? GetRegistrationInfo(GeneratorAttributeSyntaxContext context)
        {
            var symbol = context.TargetSymbol as INamedTypeSymbol;
            if (symbol is null)
                return null;

            var attribute = context.Attributes[0];
            var attributeClass = attribute.AttributeClass;
            if (attributeClass is null)
                return null;

            return new RegistrationInfo(
                symbol,
                attribute,
                attributeClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        private static string GenerateRegistrationExtensions(ImmutableArray<RegistrationInfo> registrations)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Reflection;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine();
            sb.AppendLine("namespace AttributedDI");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Extension methods for registering services marked with AttributedDI attributes.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static partial class RegistrationServiceCollectionExtensions");
            sb.AppendLine("    {");

            // Group registrations by assembly
            var assemblyGroups = registrations
                .GroupBy(r => r.TypeSymbol.ContainingAssembly.Name)
                .ToList();

            // Generate per-assembly registration methods
            foreach (var assemblyGroup in assemblyGroups)
            {
                var assemblyName = assemblyGroup.Key;
                var methodName = $"AddServicesFrom{SanitizeAssemblyName(assemblyName)}";

                sb.AppendLine();
                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Registers all services from the {assemblyName} assembly.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        /// <param name=\"services\">The service collection.</param>");
                sb.AppendLine($"        /// <returns>The service collection for chaining.</returns>");
                sb.AppendLine($"        public static IServiceCollection {methodName}(this IServiceCollection services)");
                sb.AppendLine("        {");

                foreach (var registration in assemblyGroup)
                {
                    GenerateRegistrationCode(sb, registration);
                }

                sb.AppendLine("            return services;");
                sb.AppendLine("        }");
            }

            // Generate the main AddServicesFromAssemblies method
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Registers services from the specified assemblies.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"services\">The service collection.</param>");
            sb.AppendLine("        /// <param name=\"assemblies\">The assemblies to register services from.</param>");
            sb.AppendLine("        /// <returns>The service collection for chaining.</returns>");
            sb.AppendLine("        public static IServiceCollection AddServicesFromAssemblies(this IServiceCollection services, params Assembly[] assemblies)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (assemblies == null || assemblies.Length == 0)");
            sb.AppendLine("                return services;");
            sb.AppendLine();
            sb.AppendLine("            foreach (var assembly in assemblies)");
            sb.AppendLine("            {");
            sb.AppendLine("                var assemblyName = assembly.GetName().Name;");
            sb.AppendLine("                switch (assemblyName)");
            sb.AppendLine("                {");

            foreach (var assemblyGroup in assemblyGroups)
            {
                var assemblyName = assemblyGroup.Key;
                var methodName = $"AddServicesFrom{SanitizeAssemblyName(assemblyName)}";
                sb.AppendLine($"                    case \"{assemblyName}\":");
                sb.AppendLine($"                        {methodName}(services);");
                sb.AppendLine("                        break;");
            }

            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return services;");
            sb.AppendLine("        }");

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void GenerateRegistrationCode(StringBuilder sb, RegistrationInfo registration)
        {
            var typeSymbol = registration.TypeSymbol;
            var attribute = registration.Attribute;
            var fullTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Get the lifetime from the attribute
            var lifetime = "Transient";
            var lifetimeArg = attribute.NamedArguments.FirstOrDefault(a => a.Key == "Lifetime").Value;
            if (lifetimeArg.Value != null)
            {
                lifetime = lifetimeArg.Value.ToString()!;
            }
            else if (attribute.ConstructorArguments.Length > 0)
            {
                var lastArg = attribute.ConstructorArguments[attribute.ConstructorArguments.Length - 1];
                if (lastArg.Type?.Name == "ServiceLifetime")
                {
                    lifetime = lastArg.Value?.ToString() ?? "Transient";
                }
            }

            var attributeTypeName = registration.AttributeTypeName;

            if (attributeTypeName.Contains("RegisterAsSelfAttribute"))
            {
                // services.AddXXX<TypeName>();
                sb.AppendLine($"            services.Add{lifetime}<{fullTypeName}>();");
            }
            else if (attributeTypeName.Contains("RegisterAsImplementedInterfacesAttribute"))
            {
                // Register for each implemented interface
                var interfaces = typeSymbol.AllInterfaces;
                foreach (var iface in interfaces)
                {
                    var ifaceFullName = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    sb.AppendLine($"            services.Add{lifetime}<{ifaceFullName}, {fullTypeName}>();");
                }
            }
            else if (attributeTypeName.Contains("RegisterAsAttribute"))
            {
                // Get the service type from the attribute constructor
                if (attribute.ConstructorArguments.Length > 0)
                {
                    var serviceTypeArg = attribute.ConstructorArguments[0];
                    if (serviceTypeArg.Value is INamedTypeSymbol serviceType)
                    {
                        var serviceFullName = serviceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        sb.AppendLine($"            services.Add{lifetime}<{serviceFullName}, {fullTypeName}>();");
                    }
                }
            }
        }

        private static string SanitizeAssemblyName(string assemblyName)
        {
            // Remove invalid characters from assembly name to create a valid method name
            return new string(assemblyName.Where(c => char.IsLetterOrDigit(c) || c == '_').ToArray());
        }

        private sealed record RegistrationInfo(
            INamedTypeSymbol TypeSymbol,
            AttributeData Attribute,
            string AttributeTypeName);
    }
}

