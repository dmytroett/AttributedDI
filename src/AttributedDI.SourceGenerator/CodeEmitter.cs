using AttributedDI.SourceGenerator.Strategies;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AttributedDI.SourceGenerator;

/// <summary>
/// Emits the final generated registration extension method code.
/// </summary>
internal static class CodeEmitter
{
    /// <summary>
    /// Generates a complete registration extension method file.
    /// </summary>
    /// <param name="methodName">The name of the registration method (e.g., "AddMyAssembly").</param>
    /// <param name="assemblyName">The name of the assembly being registered.</param>
    /// <param name="registrations">Service registrations to include.</param>
    /// <param name="modules">Module registrations to include.</param>
    /// <returns>The complete generated source code.</returns>
    public static string EmitRegistrationExtension(
        string methodName,
        string assemblyName,
        ImmutableArray<RegistrationInfo> registrations,
        ImmutableArray<ModuleInfo> modules)
    {
        var sb = new StringBuilder();

        // File header
        _ = sb.AppendLine("// <auto-generated/>");
        _ = sb.AppendLine("#nullable enable");
        _ = sb.AppendLine();
        _ = sb.AppendLine("using System;");
        _ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        _ = sb.AppendLine();

        // TODO: Derive namespace from assembly name to prevent collisions
        // Generate namespace from assembly name
        string namespaceName = DeriveNamespace(assemblyName);
        _ = sb.AppendLine($"namespace {namespaceName}");
        _ = sb.AppendLine("{");

        // Class declaration
        _ = sb.AppendLine("    /// <summary>");
        _ = sb.AppendLine("    /// Extension methods for registering services marked with AttributedDI attributes.");
        _ = sb.AppendLine("    /// </summary>");
        _ = sb.AppendLine("    public static partial class ServiceCollectionExtensions");
        _ = sb.AppendLine("    {");

        // Method declaration
        _ = sb.AppendLine("        /// <summary>");
        _ = sb.AppendLine($"        /// Registers all services from the {assemblyName} assembly that are marked with registration attributes.");
        _ = sb.AppendLine("        /// </summary>");
        _ = sb.AppendLine("        /// <param name=\"services\">The service collection to add services to.</param>");
        _ = sb.AppendLine("        /// <returns>The service collection for chaining.</returns>");
        _ = sb.AppendLine($"        public static IServiceCollection {methodName}(this IServiceCollection services)");
        _ = sb.AppendLine("        {");

        // Generate service registrations first
        ServiceRegistrationStrategy.GenerateCode(sb, registrations);

        // Generate module registrations after
        ModuleRegistrationStrategy.GenerateCode(sb, modules);

        // Method closing
        _ = sb.AppendLine("            return services;");
        _ = sb.AppendLine("        }");

        // Class closing
        _ = sb.AppendLine("    }");

        // Namespace closing
        _ = sb.AppendLine("}");

        return sb.ToString();
    }

    private static string DeriveNamespace(string assemblyName)
    {
        // Sanitize assembly name to create valid namespace identifier
        string sanitized = new([.. assemblyName.Where(c => char.IsLetterOrDigit(c) || c == '.' || c == '_')]);

        // Ensure namespace doesn't start with a digit
        if (sanitized.Length > 0 && char.IsDigit(sanitized[0]))
        {
            sanitized = "_" + sanitized;
        }

        // If empty or just dots/underscores, use a default
        if (string.IsNullOrWhiteSpace(sanitized.Replace(".", "").Replace("_", "")))
        {
            return "AttributedDI.Generated";
        }

        return $"{sanitized}.Generated";
    }
}