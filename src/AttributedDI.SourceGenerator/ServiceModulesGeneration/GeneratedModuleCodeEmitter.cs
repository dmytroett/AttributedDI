using AttributedDI.SourceGenerator;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Immutable;
using System.Globalization;
using System.Text;

namespace AttributedDI.SourceGenerator.ServiceModulesGeneration;

/// <summary>
/// Emits the final generated registration module and extension method code.
/// </summary>
internal static class GeneratedModuleCodeEmitter
{
    /// <summary>
    /// Generates a complete registration module file with IServiceModule implementation and extension method in separate files.
    /// </summary>
    /// <param name="context">The source production context for adding generated files.</param>
    /// <param name="moduleName">The name of the module class (e.g., "MyAssemblyModule").</param>
    /// <param name="methodName">The name of the registration method (e.g., "AddMyAssembly").</param>
    /// <param name="assemblyName">The name of the assembly being registered.</param>
    /// <param name="registrations">Service registrations to include.</param>
    public static void EmitRegistrationModule(
        SourceProductionContext context,
        string moduleName,
        string methodName,
        string namespaceName,
        string assemblyName,
        ImmutableArray<RegistrationInfo> registrations)
    {
        // Emit module class
        string moduleSource = EmitModuleClass(moduleName, namespaceName, assemblyName, registrations);
        context.AddSource($"{moduleName}.g.cs", moduleSource);

        // Emit extension methods
        string extensionSource = EmitExtensionMethod(moduleName, methodName, namespaceName, assemblyName);
        context.AddSource($"{moduleName}ServiceCollectionExtensions.g.cs", extensionSource);
    }

    private static string EmitModuleClass(string moduleName, string namespaceName, string assemblyName, ImmutableArray<RegistrationInfo> registrations)
    {
        var sb = new StringBuilder();

        // File header
        _ = sb.AppendLine("// <auto-generated/>");
        _ = sb.AppendLine("#nullable enable");
        _ = sb.AppendLine();
        _ = sb.AppendLine("using System;");
        _ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        _ = sb.AppendLine("using AttributedDI;");
        _ = sb.AppendLine();

        _ = sb.AppendLine($"namespace {namespaceName}");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("    /// <summary>");
        _ = sb.AppendLine($"    /// Service registration module for the {assemblyName} assembly.");
        _ = sb.AppendLine("    /// This module registers all services marked with AttributedDI attributes.");
        _ = sb.AppendLine("    /// </summary>");
        GeneratedCodeHelper.AppendGeneratedCodeAttribute(sb, 1);
        _ = sb.AppendLine("    [global::AttributedDI.Generated.Internal.GeneratedModuleAttribute]");
        _ = sb.AppendLine($"    public partial class {moduleName} : IServiceModule");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("        /// <summary>");
        _ = sb.AppendLine("        /// Configures services in the dependency injection container.");
        _ = sb.AppendLine("        /// </summary>");
        _ = sb.AppendLine("        /// <param name=\"services\">The service collection to configure.</param>");
        _ = sb.AppendLine("        public virtual void ConfigureServices(IServiceCollection services)");
        _ = sb.AppendLine("        {");

        // Generate service registrations
        GenerateCode(sb, registrations);

        _ = sb.AppendLine("        }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("}");

        return sb.ToString();
    }

    private static string EmitExtensionMethod(string moduleName, string methodName, string namespaceName, string assemblyName)
    {
        var sb = new StringBuilder();

        // File header
        _ = sb.AppendLine("// <auto-generated/>");
        _ = sb.AppendLine("#nullable enable");
        _ = sb.AppendLine();
        _ = sb.AppendLine("using System;");
        _ = sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        _ = sb.AppendLine("using AttributedDI;");
        _ = sb.AppendLine();

        _ = sb.AppendLine($"namespace {namespaceName}");
        _ = sb.AppendLine("{");
        _ = sb.AppendLine("    /// <summary>");
        _ = sb.AppendLine($"    /// Extension methods for registering services from the {moduleName} module.");
        _ = sb.AppendLine("    /// </summary>");
        GeneratedCodeHelper.AppendGeneratedCodeAttribute(sb, 1);
        _ = sb.AppendLine($"    public static partial class {moduleName}ServiceCollectionExtensions");
        _ = sb.AppendLine("    {");
        _ = sb.AppendLine("        /// <summary>");
        _ = sb.AppendLine($"        /// Registers all services from the {assemblyName} assembly that are marked with registration attributes.");
        _ = sb.AppendLine("        /// </summary>");
        _ = sb.AppendLine("        /// <param name=\"services\">The service collection to add services to.</param>");
        _ = sb.AppendLine("        /// <returns>The service collection for chaining.</returns>");
        _ = sb.AppendLine($"        public static IServiceCollection {methodName}(this IServiceCollection services)");
        _ = sb.AppendLine("        {");
        _ = sb.AppendLine($"            return services.AddModule<{moduleName}>();");
        _ = sb.AppendLine("        }");
        _ = sb.AppendLine("    }");
        _ = sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates service registration code.
    /// </summary>
    /// <param name="sb">The string builder to append code to.</param>
    /// <param name="registrations">The registrations to generate code for.</param>
    private static void GenerateCode(StringBuilder sb, ImmutableArray<RegistrationInfo> registrations)
    {
        foreach (var registration in registrations)
        {
            GenerateRegistrationCode(sb, registration);
        }
    }

    private static void GenerateRegistrationCode(StringBuilder sb, RegistrationInfo registration)
    {
        var fullTypeName = registration.IsOpenGeneric
            ? registration.UnboundImplementationTypeName
            : registration.FullyQualifiedTypeName;
        var serviceType = registration.IsOpenGeneric
            ? registration.UnboundServiceTypeFullName ?? registration.ServiceTypeFullName
            : registration.ServiceTypeFullName;
        var lifetime = registration.Lifetime;
        var isKeyed = registration.Key != null;

        if (registration.IsOpenGeneric)
        {
            EmitOpenGenericRegistration(sb, serviceType, fullTypeName, lifetime, isKeyed, registration.Key);
            return;
        }

        if (serviceType is string)
        {
            EmitClosedGenericRegistration(sb, serviceType, fullTypeName, lifetime, isKeyed, registration.Key);
            return;
        }

        EmitClosedSelfRegistration(sb, fullTypeName, lifetime, isKeyed, registration.Key);
    }

    private static void EmitClosedGenericRegistration(StringBuilder sb, string serviceType, string implementationType, string lifetime, bool isKeyed, object? key)
    {
        if (!isKeyed)
        {
            _ = sb.AppendLine($"            services.Add{lifetime}<{serviceType}, {implementationType}>();");
            return;
        }

        var keyLiteral = FormatKeyLiteral(key);
        _ = sb.AppendLine($"            services.AddKeyed{lifetime}<{serviceType}, {implementationType}>({keyLiteral});");
    }

    private static void EmitClosedSelfRegistration(StringBuilder sb, string implementationType, string lifetime, bool isKeyed, object? key)
    {
        if (!isKeyed)
        {
            _ = sb.AppendLine($"            services.Add{lifetime}<{implementationType}>();");
            return;
        }

        var keyLiteral = FormatKeyLiteral(key);
        _ = sb.AppendLine($"            services.AddKeyed{lifetime}<{implementationType}>({keyLiteral});");
    }

    private static void EmitOpenGenericRegistration(StringBuilder sb, string? serviceType, string implementationType, string lifetime, bool isKeyed, object? key)
    {
        if (serviceType is string)
        {
            if (!isKeyed)
            {
                _ = sb.AppendLine($"            services.Add{lifetime}(typeof({serviceType}), typeof({implementationType}));");
                return;
            }

            var keyLiteral = FormatKeyLiteral(key);
            _ = sb.AppendLine($"            services.AddKeyed{lifetime}(typeof({serviceType}), {keyLiteral}, typeof({implementationType}));");
            return;
        }

        if (!isKeyed)
        {
            _ = sb.AppendLine($"            services.Add{lifetime}(typeof({implementationType}));");
            return;
        }

        var selfKeyLiteral = FormatKeyLiteral(key);
        _ = sb.AppendLine($"            services.AddKeyed{lifetime}(typeof({implementationType}), {selfKeyLiteral});");
    }

    /// <summary>
    /// Formats a key value as a C# literal for code generation.
    /// </summary>
    /// <param name="key">The key value to format.</param>
    /// <returns>A string representation of the key suitable for code generation.</returns>
    private static string FormatKeyLiteral(object? key)
    {
        return key switch
        {
            KeyLiteral literal => literal.Literal,
            null => "null",
            string s => $"\"{s.Replace("\"", "\\\"")}\"",
            int i => i.ToString(CultureInfo.InvariantCulture),
            long l => $"{l}L",
            bool b => b ? "true" : "false",
            _ => $"\"{key}\""
        };
    }
}