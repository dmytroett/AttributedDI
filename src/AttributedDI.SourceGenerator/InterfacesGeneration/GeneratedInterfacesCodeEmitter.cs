using AttributedDI.SourceGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Text;

namespace AttributedDI.SourceGenerator.InterfacesGeneration;

internal static class GeneratedInterfacesCodeEmitter
{
    public static void EmitInterfaces(SourceProductionContext context, ImmutableArray<GeneratedInterfaceInfo> interfacesToGenerate)
    {
        foreach (var interfaceInfo in interfacesToGenerate)
        {
            // Generate the interface
            var interfaceSource = BuildInterfaceSource(interfaceInfo);
            var interfaceHintName = CreateInterfaceHintName(interfaceInfo);
            context.AddSource(interfaceHintName, SourceText.From(interfaceSource, Encoding.UTF8));

            // Generate the partial class implementation
            var classSource = BuildPartialClassSource(interfaceInfo);
            var classHintName = CreateClassHintName(interfaceInfo);
            context.AddSource(classHintName, SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private static string BuildInterfaceSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.InterfaceNamespace))
        {
            builder.Append("namespace ").Append(interfaceInfo.InterfaceNamespace).AppendLine(";");
            builder.AppendLine();
        }

        GeneratedCodeHelper.AppendGeneratedCodeAttribute(builder, 0);
        builder.Append(interfaceInfo.Accessibility)
            .Append(" interface ")
            .Append(interfaceInfo.InterfaceName)
            .Append(interfaceInfo.ClassTypeParameters)
            .AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.TypeParameterConstraints))
        {
            builder.Append(interfaceInfo.TypeParameterConstraints).AppendLine();
        }

        builder.AppendLine("{");

        foreach (var member in interfaceInfo.MemberSignatures)
        {
            builder.Append("    ").Append(member);
            var needsSemicolon = !member.Contains("{", StringComparison.Ordinal) && !member.EndsWith(";", StringComparison.Ordinal);
            if (needsSemicolon)
            {
                builder.Append(';');
            }

            builder.AppendLine();
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string BuildPartialClassSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.ClassNamespace))
        {
            builder.Append("namespace ").Append(interfaceInfo.ClassNamespace).AppendLine(";");
            builder.AppendLine();
        }

        GeneratedCodeHelper.AppendGeneratedCodeAttribute(builder, 0);
        // Build the partial class declaration that implements the interface
        builder.Append(interfaceInfo.Accessibility)
            .Append(" partial class ")
            .Append(interfaceInfo.ClassName)
            .Append(interfaceInfo.ClassTypeParameters)
            .Append(" : ")
            .Append(BuildFullyQualifiedName(interfaceInfo.InterfaceNamespace, interfaceInfo.InterfaceName));

        // Add type parameters to the interface reference if needed
        if (!string.IsNullOrEmpty(interfaceInfo.ClassTypeParameters))
        {
            builder.Append(interfaceInfo.ClassTypeParameters);
        }

        if (!string.IsNullOrWhiteSpace(interfaceInfo.TypeParameterConstraints))
        {
            builder.Append(' ').Append(interfaceInfo.TypeParameterConstraints);
        }

        builder.AppendLine();
        builder.AppendLine("{");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string CreateInterfaceHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namespacePart = string.IsNullOrWhiteSpace(interfaceInfo.InterfaceNamespace)
            ? "Global"
            : interfaceInfo.InterfaceNamespace.Replace('.', '_');

        var namePart = SanitizeForHintName(interfaceInfo.InterfaceName + BuildGenericArityHintSuffix(interfaceInfo.TypeParameterCount));

        return $"{namespacePart}_{namePart}.g.cs";
    }

    private static string CreateClassHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namespacePart = string.IsNullOrWhiteSpace(interfaceInfo.ClassNamespace)
            ? "Global"
            : interfaceInfo.ClassNamespace.Replace('.', '_');

        var namePart = SanitizeForHintName(interfaceInfo.ClassName + BuildGenericArityHintSuffix(interfaceInfo.TypeParameterCount));

        return $"{namespacePart}_{namePart}.g.cs";
    }

    private static string BuildFullyQualifiedName(string @namespace, string name)
    {
        return string.IsNullOrWhiteSpace(@namespace)
            ? name
            : $"{@namespace}.{name}";
    }

    private static string SanitizeForHintName(string value)
    {
        const string invalid = "<>:\"/\\|?*, ";
        var builder = new StringBuilder(value.Length);

        foreach (var ch in value)
        {
            builder.Append(invalid.IndexOf(ch) >= 0 ? '_' : ch);
        }

        return builder.ToString();
    }

    private static string BuildGenericArityHintSuffix(int typeParameterCount)
    {
        return typeParameterCount > 0
            ? $"`{typeParameterCount}"
            : string.Empty;
    }
}