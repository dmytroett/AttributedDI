using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Text;

namespace AttributedDI.SourceGenerator.InterfacesGeneration;

internal static class GeneratedInterfacesCodeEmitter
{
    public static void EmitInterfaces(SourceProductionContext context, ImmutableArray<GeneratedInterfaceInfo> interfacesToGenerate)
    {
        foreach (var interfaceInfo in interfacesToGenerate)
        {
            // Generate the interface
            var interfaceSource = BuildInterfaceSource(interfaceInfo);
            var interfaceHintName = CreateInterfaceHintName(interfaceInfo);
            context.AddSource(interfaceHintName, SourceText.From(interfaceSource, Encoding.UTF8));

            // Generate the partial class implementation
            var classSource = BuildPartialClassSource(interfaceInfo);
            var classHintName = CreateClassHintName(interfaceInfo);
            context.AddSource(classHintName, SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private static string BuildInterfaceSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.InterfaceNamespace))
        {
            builder.Append("namespace ").Append(interfaceInfo.InterfaceNamespace).AppendLine(";");
            builder.AppendLine();
        }

        builder.Append(interfaceInfo.Accessibility)
            .Append(" interface ")
            .Append(interfaceInfo.InterfaceName)
            .AppendLine();
        builder.AppendLine("{");

        foreach (var member in interfaceInfo.MemberSignatures)
        {
            builder.Append("    ").Append(member);
            if (!member.EndsWith(";", StringComparison.Ordinal))
            {
                builder.Append(';');
            }

            builder.AppendLine();
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string BuildPartialClassSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.ClassNamespace))
        {
            builder.Append("namespace ").Append(interfaceInfo.ClassNamespace).AppendLine(";");
            builder.AppendLine();
        }

        // Build the partial class declaration that implements the interface
        builder.Append(interfaceInfo.Accessibility)
            .Append(" partial class ")
            .Append(interfaceInfo.ClassName)
            .Append(interfaceInfo.ClassTypeParameters)
            .Append(" : ")
            .Append(interfaceInfo.FullyQualifiedName);

        // Add type parameters to the interface reference if needed
        if (!string.IsNullOrEmpty(interfaceInfo.ClassTypeParameters))
        {
            builder.Append(interfaceInfo.ClassTypeParameters);
        }

        builder.AppendLine();
        builder.AppendLine("{");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string CreateInterfaceHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namespacePart = string.IsNullOrWhiteSpace(interfaceInfo.InterfaceNamespace)
            ? "Global"
            : interfaceInfo.InterfaceNamespace.Replace('.', '_');

        return $"GeneratedInterfaces_{namespacePart}_{interfaceInfo.InterfaceName}.g.cs";
    }

    private static string CreateClassHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namespacePart = string.IsNullOrWhiteSpace(interfaceInfo.ClassNamespace)
            ? "Global"
            : interfaceInfo.ClassNamespace.Replace('.', '_');

        return $"GeneratedInterfacesImpl_{namespacePart}_{interfaceInfo.ClassName}.g.cs";
    }
}