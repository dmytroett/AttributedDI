using AttributedDI.SourceGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Text;

namespace AttributedDI.SourceGenerator.InterfacesGeneration;

internal static class GeneratedInterfacesCodeEmitter
{
    public static void EmitInterfaces(SourceProductionContext context, ImmutableArray<GeneratedInterfaceInfo> interfacesToGenerate)
    {
        foreach (var interfaceInfo in interfacesToGenerate)
        {
            // Generate the interface
            var interfaceSource = BuildInterfaceSource(interfaceInfo);
            var interfaceHintName = CreateInterfaceHintName(interfaceInfo);
            context.AddSource(interfaceHintName, SourceText.From(interfaceSource, Encoding.UTF8));

            // Generate the partial class implementation
            var classSource = BuildPartialClassSource(interfaceInfo);
            var classHintName = CreateClassHintName(interfaceInfo);
            context.AddSource(classHintName, SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private static string BuildInterfaceSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        var interfaceNamespace = NormalizeNamespace(interfaceInfo.InterfaceNamespace);
        if (!string.IsNullOrWhiteSpace(interfaceNamespace))
        {
            builder.Append("namespace ").Append(interfaceNamespace).AppendLine(";");
            builder.AppendLine();
        }

        GeneratedCodeHelper.AppendGeneratedCodeAttribute(builder, 0);
        builder.Append(interfaceInfo.Accessibility)
            .Append(" interface ")
            .Append(interfaceInfo.InterfaceName)
            .Append(interfaceInfo.ClassTypeParameters)
            .AppendLine();

        if (!string.IsNullOrWhiteSpace(interfaceInfo.TypeParameterConstraints))
        {
            builder.Append(interfaceInfo.TypeParameterConstraints).AppendLine();
        }

        builder.AppendLine("{");

        foreach (var member in interfaceInfo.MemberSignatures)
        {
            builder.Append("    ").Append(member);
            var needsSemicolon = !member.Contains("{", StringComparison.Ordinal) && !member.EndsWith(";", StringComparison.Ordinal);
            if (needsSemicolon)
            {
                builder.Append(';');
            }

            builder.AppendLine();
        }

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string BuildPartialClassSource(GeneratedInterfaceInfo interfaceInfo)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        var classNamespace = NormalizeNamespace(interfaceInfo.ClassNamespace);
        if (!string.IsNullOrWhiteSpace(classNamespace))
        {
            builder.Append("namespace ").Append(classNamespace).AppendLine(";");
            builder.AppendLine();
        }

        GeneratedCodeHelper.AppendGeneratedCodeAttribute(builder, 0);
        // Build the partial class declaration that implements the interface
        var fullyQualifiedInterfaceName = BuildFullyQualifiedName(interfaceInfo.InterfaceNamespace, interfaceInfo.InterfaceName);
        
        builder.Append(interfaceInfo.Accessibility)
            .Append(" partial class ")
            .Append(interfaceInfo.ClassName)
            .Append(interfaceInfo.ClassTypeParameters)
            .Append(" : ")
            .Append(fullyQualifiedInterfaceName);

        // Add type parameters to the interface reference if needed
        if (!string.IsNullOrEmpty(interfaceInfo.ClassTypeParameters))
        {
            builder.Append(interfaceInfo.ClassTypeParameters);
        }

        if (!string.IsNullOrWhiteSpace(interfaceInfo.TypeParameterConstraints))
        {
            builder.Append(' ').Append(interfaceInfo.TypeParameterConstraints);
        }

        builder.AppendLine();
        builder.AppendLine("{");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string CreateInterfaceHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namePart = SanitizeForHintName(interfaceInfo.InterfaceName + BuildGenericArityHintSuffix(interfaceInfo.TypeParameterCount));
        return CreateHintName(interfaceInfo.InterfaceNamespace, namePart);
    }

    private static string CreateClassHintName(GeneratedInterfaceInfo interfaceInfo)
    {
        var namePart = SanitizeForHintName(interfaceInfo.ClassName + BuildGenericArityHintSuffix(interfaceInfo.TypeParameterCount));
        return CreateHintName(interfaceInfo.ClassNamespace, namePart);
    }

    private static string BuildFullyQualifiedName(string @namespace, string name)
    {
        var normalized = NormalizeNamespace(@namespace);
        return string.IsNullOrWhiteSpace(normalized)
            ? name
            : $"{normalized}.{name}";
    }

    private static string SanitizeForHintName(string value)
    {
        const string invalid = "<>:\"/\\|?*, ";
        var builder = new StringBuilder(value.Length);

        foreach (var ch in value)
        {
            builder.Append(invalid.IndexOf(ch) >= 0 ? '_' : ch);
        }

        return builder.ToString();
    }

    private static string BuildGenericArityHintSuffix(int typeParameterCount)
    {
        return typeParameterCount > 0
            ? $"`{typeParameterCount}"
            : string.Empty;
    }

    private static string CreateHintName(string? @namespace, string typeName)
    {
        var normalized = NormalizeNamespace(@namespace);
        // Roslyn uses "<global namespace>" for types declared without an explicit namespace (top-level files).
        if (string.IsNullOrWhiteSpace(normalized))
        {
            return $"Global.{typeName}.g.cs";
        }

        return $"{normalized}.{typeName}.g.cs";
    }

    private static string NormalizeNamespace(string? @namespace)
    {
        if (string.IsNullOrWhiteSpace(@namespace))
        {
            return string.Empty;
        }

        if (string.Equals(@namespace, "<global namespace>", StringComparison.Ordinal))
        {
            return string.Empty;
        }

        const string prefix = "global::";
        return @namespace!.StartsWith(prefix, StringComparison.Ordinal)
            ? @namespace.Substring(prefix.Length)
            : @namespace;
    }
}